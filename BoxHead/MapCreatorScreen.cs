/*
 * V.0.0.11 28/05/2018 - Javier Saorín Vidal: Added methods to save the list of
 * obstacles generated by the user in a level file, which icreases automatically.
 */

using System;
using System.Collections.Generic;
using System.IO;
using Tao.Sdl;

class MapCreatorScreen : Screen
{
    public struct LogError
    {
        public DateTime date;
        public string type;
        public string description;
    }

    private Image background;
    private Image wall;
    private Image spawn;
    private Image barrel;

    private Image mapWall, mapSpawn, mapBarrel;

    private IntPtr helpText;
    private IntPtr finishText;

    private IntPtr[] nums;
    private bool displayHelp;
    private int mouseClickX, mouseClickY;
    private int mouseX, mouseY;
    int selectedImage;

    private List<Obstacle> newObstacles;

    public MapCreatorScreen(Hardware hardware) : base(hardware)
    {
        background = new Image("imgs/others/floor.png", 1280, 720);
        wall = new Image("imgs/obstacles/wall.png", 40, 40);
        spawn = new Image("imgs/obstacles/spawnpoint.png", 50, 50);
        barrel = new Image("imgs/obstacles/barrel.png", 36, 36);

        mapWall = new Image("imgs/others/wall-map.png", 20, 20);
        mapSpawn = new Image("imgs/others/spawnpoint-map.png", 25, 25);
        mapBarrel = new Image("imgs/others/barrel-map.png", 18, 18);
        
        helpText = new IntPtr();
        nums = new IntPtr[3];
        initialiceTexts();
        displayHelp = false;
        selectedImage = 1;
        newObstacles = new List<Obstacle>();
    }

    public override void Show()
    {
        background.MoveTo(0, 0);
        wall.MoveTo(
            (GameController.SCREEN_WIDTH / 2) - 60, 
            GameController.SCREEN_HEIGHT - 90);
        spawn.MoveTo(
            (GameController.SCREEN_WIDTH / 2 + 30),
            GameController.SCREEN_HEIGHT - 90);
        barrel.MoveTo(
            (GameController.SCREEN_WIDTH / 2) + 140, 
            GameController.SCREEN_HEIGHT - 90);

        do
        {
            // Draw everything.
            hardware.ClearScreen();
            hardware.DrawImage(background);

            foreach (Obstacle o in newObstacles)
            {
                o.Image.MoveTo(o.X, o.Y);
                hardware.DrawImage(o.Image);
            }

            if (!displayHelp)
            {
                hardware.WriteText(
                    helpText, (GameController.SCREEN_WIDTH / 2) - 50,
                    GameController.SCREEN_HEIGHT - 50);
            }
            else
            {
                hardware.WriteText(
                    finishText, GameController.SCREEN_WIDTH - 150, 10);

                short xPos = (GameController.SCREEN_WIDTH / 2) - 50;
                for (int i = 0; i < nums.Length; i++)
                {
                    hardware.WriteText(
                        nums[i], xPos, GameController.SCREEN_HEIGHT - 150);
                    xPos += 100;
                    hardware.DrawImage(wall);
                    hardware.DrawImage(spawn);
                    hardware.DrawImage(barrel);
                }
            }
            
            hardware.UpdateScreen();

            // Check user input.

            hardware.GetEvents(
                out mouseX, out mouseY, out mouseClickX, out mouseClickY);

            if (mouseClickX != -1 && mouseClickY != -1)
                addObstacle();

            if (hardware.IsKeyPressed(Hardware.KEY_TAB))
                displayHelp = !displayHelp;
            else if (hardware.IsKeyPressed(Hardware.KEY_1))
                selectedImage = 1;
            else if (hardware.IsKeyPressed(Hardware.KEY_2))
                selectedImage = 2;
            else if (hardware.IsKeyPressed(Hardware.KEY_3))
                selectedImage = 3;
        }
        while (!isFinished());
        saveMap();
    }

    private void saveMap()
    {
        int lastLevel = getLastLevel();
        if (lastLevel != -1)
        {
            int actualLevel = lastLevel + 1;

            if (Directory.Exists("./levels"))
            {
                try
                {
                    string savePath = "./levels/level" + actualLevel + ".txt";
                    StreamWriter output = new StreamWriter(savePath);

                    foreach (Obstacle o in newObstacles)
                    {
                        char type = getTypeOfObstacle(o);
                        output.WriteLine(
                                type + ";" + (o.X * 2) + ";" + (o.Y * 2));
                    }
                    output.Close();
                }
                catch (FileNotFoundException e)
                {
                    LogError error;
                    error.date = DateTime.Now;
                    error.type = "File not found";
                    error.description = e.Message;
                    saveErrorLog(error);
                }
                catch (PathTooLongException e)
                {
                    LogError error;
                    error.date = DateTime.Now;
                    error.type = "Path too long exception";
                    error.description = e.Message;
                    saveErrorLog(error);
                }
                catch (IOException e)
                {
                    LogError error;
                    error.date = DateTime.Now;
                    error.type = "IO Exception";
                    error.description = e.Message;
                    saveErrorLog(error);
                }
                catch (Exception e)
                {
                    LogError error;
                    error.date = DateTime.Now;
                    error.type = "Unknown error";
                    error.description = e.Message;
                    saveErrorLog(error);
                }
            }
        }
    }

    private char getTypeOfObstacle(Obstacle o)
    {
        return Convert.ToChar(o.ToString().Split(';')[0]);
    }

    private int getLastLevel()
    {
        if (Directory.Exists("./levels"))
        {
            string[] fileList;
            fileList = Directory.GetFiles("./levels");

            int maxLevel = 1;
            int fileLevel;
            foreach (string file in fileList)
            {
                if (file.StartsWith("./levels\\level"))
                {
                    int amountOfDigits = file.LastIndexOf('.') - 1 - file.LastIndexOf('l');
                    string level = file.Substring(file.LastIndexOf('l') + 1, amountOfDigits);
                    fileLevel = int.Parse(level);

                    if (fileLevel > maxLevel)
                        maxLevel = fileLevel;
                }
            }
            return maxLevel;
        }
        return -1;
    }

    private void addObstacle()
    {
        switch (selectedImage)
        {
            case 1:
                newObstacles.Add(
                    new Wall(mapWall, 
                    (short)(mouseClickX), 
                    (short)(mouseClickY)));
                break;
            case 2:
                newObstacles.Add(
                    new SpawnPoint(mapSpawn, 
                    (short)(mouseClickX), 
                    (short)(mouseClickY)));
                break;
            case 3:
                newObstacles.Add(
                    new Barrel(mapBarrel, 
                    (short)(mouseClickX), 
                    (short)(mouseClickY)));
                break;
            default:
                break;
        }
    }

    private void saveErrorLog(LogError log)
    {
        string errorLine = log.date.ToString("dd-MM-yyyy - hh:mm: ") +
            log.type + ": " + log.description;
        File.AppendAllText("errorLog.log", errorLine);
    }

    private bool isFinished()
    {
        return hardware.IsKeyPressed(Hardware.KEY_ESC);
    }

    private void initialiceTexts()
    {
        helpText = SdlTtf.TTF_RenderText_Solid(
                new Font("fonts/Creepster-Regular.ttf", 20).GetFontType(),
                "Press TAB to show help", hardware.Red);

        finishText = SdlTtf.TTF_RenderText_Solid(
                new Font("fonts/Creepster-Regular.ttf", 18).GetFontType(),
                "Press ESC to finish", hardware.Red);

        for (int i = 1; i <= nums.Length; i++)
            nums[i-1] = SdlTtf.TTF_RenderText_Solid(
                new Font("fonts/Creepster-Regular.ttf", 40).GetFontType(),
                i.ToString(), hardware.Red);
    }
}
